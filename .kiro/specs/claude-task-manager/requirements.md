# 要件文書

## はじめに

sage（賢者）は、Claude DesktopとClaude Code向けのMCPサーバーとして実装されるAIアシスタントです。タスク管理、優先順位付け、リマインド設定、カレンダー統合を自動化します。システムは個人の作業パターンを学習し、パーソナライズされたタスク整理とスケジューリング推奨を提供します。

このプラグインは最初にMercariのエンジニア（個人貢献者およびエンジニアリングマネージャー）をターゲットとし、将来的には全社展開を計画しています。Apple Reminders（AppleScript経由）、Notion（MCP経由）、カレンダー（AppleScript経由）と統合し、macOS環境でシームレスなタスク管理を提供します。

## プラットフォーム対応状況

| プラットフォーム | 状態 | 備考 |
|----------------|------|------|
| Desktop MCP (macOS) | ✅ 実装済み | AppleScript、ファイルシステム、Notion MCP |
| iOS/iPadOS | ✅ **Remote MCP対応** | Remote MCPサーバー経由で完全機能 |
| Web | ✅ **Remote MCP対応** | Remote MCPサーバー経由で完全機能 |

> **Remote MCP対応**: iOS/iPadOSとWebブラウザからClaude.aiを使用する際、Remote MCPサーバー経由でデスクトップ版と同等の完全機能にアクセス可能です。ネイティブSkills統合は不要となりました。

## 要件

### 要件1: 初期セットアップと設定

**ユーザーストーリー:** 新規ユーザーとして、3分以内に初期セットアップを完了したい。複雑な設定なしにすぐにAIアシスタントを使い始められるようにするため。

#### 受け入れ基準

1. ユーザーが初回プラグインを起動したとき、システムは設定ファイルの存在を確認すること
2. 設定ファイルが存在しない場合、システムはセットアップが必要であることを表示すること
3. ユーザーがセットアップウィザードを開始したとき、システムは最大10問の質問を提示すること
4. ユーザーがすべてのセットアップ質問を完了したとき、システムは30秒以内に設定ファイルを生成すること
5. 設定が保存されたとき、システムは~/.sage/config.jsonに保存すること
6. セットアップが完了したとき、システムはユーザーに設定成功を確認すること

### 要件2: タスク分析と優先順位付け

**ユーザーストーリー:** 忙しいエンジニアとして、システムに自動的にタスクを分析して優先順位を割り当ててもらいたい。最も重要な作業に最初に集中できるようにするため。

#### 受け入れ基準

1. ユーザーがタスクリストを提供したとき、システムは各タスクの優先度レベルを分析すること
2. 優先度を分析するとき、システムは設定されたルールに基づいてP0、P1、P2、P3を割り当てること
3. タスクに期限キーワードが含まれているとき、システムは緊急度に基づいて優先順位を付けること
4. タスクにユーザーのマネージャーが言及されているとき、システムはより高い優先度を考慮すること
5. 優先度が決定されたとき、システムは割り当ての理由を提供すること
6. タスクが分析されたとき、システムは完了時間を分単位で見積もること

### 要件3: 時間見積もりとスケジューリング

**ユーザーストーリー:** ユーザーとして、システムにタスクの所要時間を見積もってもらい、いつ実行するかを提案してもらいたい。効果的に一日を計画できるようにするため。

#### 受け入れ基準

1. タスクを分析するとき、システムはキーワードに基づいて完了時間を見積もること
2. 時間を見積もるとき、システムは設定された時間マッピング（簡単：25分、複雑：75分など）を使用すること
3. 利用可能な時間枠を見つけるとき、システムはユーザーのカレンダーを確認すること
4. カレンダーを確認するとき、システムは設定された勤務時間を尊重すること
5. 時間枠を提案するとき、システムは深い作業日と会議の多い日を考慮すること
6. 競合がない場合、システムは理由付きで最適な時間枠を提案すること

### 要件4: 関係者の識別

**ユーザーストーリー:** チームメンバーとして、システムにタスクに関わる他の人を識別してもらいたい。適切な人と効果的に連携できるようにするため。

#### 受け入れ基準

1. タスクを分析するとき、システムはタスク内容から関係者名を抽出すること
2. 関係者を抽出するとき、システムは設定されたチームメンバーを認識すること
3. @メンションを見つけたとき、システムはそれらを関係者として含めること
4. マネージャーキーワードが検出されたとき、システムはマネージャーの関与をフラグ付けすること
5. 関係者が識別されたとき、システムは関連する人のリストを返すこと

### 要件5: リマインド管理

**ユーザーストーリー:** 忘れっぽい人として、システムにタスクの適切なリマインドを設定してもらいたい。重要な期限を逃さないようにするため。

#### 受け入れ基準

1. タスクに期限があるとき、システムは適切なリマインド時間を提案すること
2. 期限が7日以内のとき、システムはApple Remindersを作成すること
3. 期限が8日以上先のとき、システムはNotionエントリを作成すること
4. **期限が設定されていないとき、システムはNotionエントリを作成すること（無限の未来と仮定）**
5. リマインドを設定するとき、システムは設定されたリマインド設定を使用すること
6. リマインドが作成されたとき、システムは作成成功を確認すること
7. リマインド作成が失敗したとき、システムはエラー詳細を提供すること

### 要件6: カレンダー統合

**ユーザーストーリー:** カレンダーに依存する作業者として、システムに私のスケジュールを理解してもらい、現実的な時間枠を提案してもらいたい。既存のコミットメントの周りでタスクを計画できるようにするため。

#### 受け入れ基準

1. 空き状況を確認するとき、システムは利用可能なカレンダー統合方法を検出すること
2. macOSで動作するとき、システムはAppleScript経由でCalendar.appから情報を取得すること
3. カレンダーを分析するとき、システムは空いている時間枠を識別すること
4. 時間枠を評価するとき、システムは設定された深い作業日を考慮すること
5. 会議の多い日が設定されているとき、システムはそれらの枠をあまり適さないとマークすること
6. 競合が検出されたとき、システムはその時間帯を除外すること
7. 枠を提案するとき、システムは適合性でランク付けし、使用したカレンダー統合方法を明記すること
8. カレンダーアクセスが利用できない場合、システムは手動入力プロンプトを提供すること

### 要件7: クロスプラットフォーム互換性

**ユーザーストーリー:** Claude DesktopとClaude Codeの両方のユーザーとして、両方の環境で同じ機能を使いたい。どちらのツールを使っていても一貫したタスク管理ができるようにするため。

#### 受け入れ基準

1. MCPサーバーとしてデプロイされたとき、システムはClaude Desktopで動作すること
2. MCPサーバーとしてデプロイされたとき、システムはClaude Codeで動作すること
3. どちらのMCPクライアントを使用しても、システムは同一の機能を提供すること
4. 設定ファイルが存在するとき、両方のMCPクライアントは同じ設定ファイル（~/.sage/config.json）を使用すること
5. ツールが呼び出されたとき、両方のMCPクライアントは同じ結果を返すこと
6. iOS/iPadOS/Webからの接続時、Remote MCPサーバー経由で同等の機能を提供すること

### 要件8: Notion統合

**ユーザーストーリー:** Notionユーザーとして、長期タスクを自動的にNotionデータベースに同期してもらいたい。好みのツールでプロジェクトを管理できるようにするため。

#### 受け入れ基準

1. タスクの期限が8日以上先、または期限が設定されていないとき、システムはNotion MCP Server経由でNotionに同期すること
2. Notionに同期するとき、システムは設定されたデータベースIDを使用すること
3. Notionページを作成するとき、システムはタイトル、優先度、期限、関係者を含めること
4. 同期が成功したとき、システムはNotionページURLを返すこと
5. MCP通信が失敗したとき、システムはエラー詳細と手動コピー用テキストを提供すること

> **注意**: Notion統合にはNotion MCP Serverが事前に設定されている必要があります。
> **注意**: 期限が設定されていないタスクは「無限の未来」と仮定し、長期タスクとしてNotionで管理されます。

### 要件9: Apple Reminders統合

**ユーザーストーリー:** Appleエコシステムユーザーとして、短期タスクをApple Remindersに追加してもらいたい。すべてのデバイスでネイティブ通知を受け取れるようにするため。

#### 受け入れ基準

1. タスクの期限が7日以内のとき、システムはApple Remindersを作成すること
2. macOSで動作するとき、システムはAppleScript統合を使用すること
3. リマインダーを作成するとき、システムは設定されたリマインダーリストを使用すること
4. リマインダーが作成されたとき、システムは適切な期限日とアラームを設定すること
5. 作成が失敗したとき、システムはエラー詳細と使用した統合方法を提供すること
6. AppleScript統合が利用できない場合、システムは手動コピー用テキストを生成すること

> **注意**: iOS/iPadOS/WebからはRemote MCPサーバー経由でApple Reminders統合を利用できます。

### 要件10: 設定管理

**ユーザーストーリー:** 変化する設定を持つユーザーとして、設定を更新したい。システムが進化する作業パターンに適応できるようにするため。

#### 受け入れ基準

1. 設定の更新が必要なとき、システムは部分更新を許可すること
2. カレンダー設定を更新するとき、システムは勤務時間形式を検証すること
3. 優先度ルールを更新するとき、システムはルール構文を検証すること
4. 統合を更新するとき、システムはAPI接続をテストすること
5. 更新が保存されたとき、システムは変更成功を確認すること
6. 検証が失敗したとき、システムは具体的なエラーメッセージを提供すること

### 要件11: タスク分割と整理

**ユーザーストーリー:** 複雑なタスクや複数のタスクを一度に伝えるユーザーとして、システムに適切なサイズのタスクに分割してもらいたい。管理しやすく実行可能なタスクの集合にするため。

#### 受け入れ基準

1. ユーザーが複数のタスクを含む文章を提供したとき、システムは個別のタスクに分離すること
2. ユーザーが大きなタスクを提供したとき、システムは実行可能なサブタスクに分割すること
3. タスクを分割するとき、システムは各サブタスクが独立して実行可能であることを確認すること
4. タスクを分割するとき、システムは元のタスクの意図と目標を保持すること
5. 分割されたタスクには適切な順序や依存関係が設定されること
6. 分割結果をユーザーに提示するとき、システムは分割理由と推奨実行順序を説明すること

### 要件12: TODOリスト管理

**ユーザーストーリー:** 継続的にタスクを管理するユーザーとして、既存のTODOやタスクを一覧表示し、ステータスを更新したい。進行中の作業を効率的に追跡・管理できるようにするため。

#### 受け入れ基準

1. ユーザーがTODOリストを要求したとき、システムはすべての統合ソースからタスクを集約すること
2. Apple Remindersからタスクを取得するとき、システムは未完了のリマインダーを表示すること
3. Notionからタスクを取得するとき、システムは設定されたデータベースから未完了タスクを表示すること
4. タスクを表示するとき、システムは優先度、期限、ステータス、作成日を含めること
5. ユーザーがタスクのステータス更新を要求したとき、システムは該当するソース（Apple Reminders/Notion）で更新すること
6. タスクが完了としてマークされたとき、システムは統合されたすべてのソースで同期すること
7. フィルタリングが要求されたとき、システムは優先度、期限、ステータス別にタスクを絞り込むこと
8. 今日のタスクが要求されたとき、システムは本日期限または今日実行予定のタスクのみを表示すること

### 要件13: Remote MCP Server対応

**ユーザーストーリー:** iOS/iPadOSやWebブラウザからClaude.aiを使用するユーザーとして、デスクトップ版と同じ完全なsage機能にアクセスしたい。どのプラットフォームからでも一貫したタスク管理体験を得られるようにするため。

#### 受け入れ基準

1. Remote MCPサーバーが起動したとき、システムはHTTPS/WebSocket接続を受け入れること ✅
2. Claude iOS/iPadOS/Webからの接続時、システムはOAuth認証を実行すること ⚠️ **未実装** (Claude iOSはOAuth 2.0のみサポート、現状は認証なしモードで代替)
3. 認証が成功したとき、システムはユーザー固有の設定とデータにアクセスを提供すること ✅
4. Remote MCP経由でツールが呼び出されたとき、システムはLocal MCP版と同じ結果を返すこと ⚠️ **未実装** (HTTPサーバーのMCPハンドラーがプレースホルダー実装)
5. ユーザー設定が更新されたとき、システムはクラウドストレージに永続化すること ✅
6. 複数デバイスから同時アクセスがあったとき、システムは設定の競合を適切に解決すること ✅
7. レート制限に達したとき、システムは適切なエラーメッセージを返すこと ✅
8. 外部API統合時、システムはWeb API経由で同等の機能を提供すること ⚠️ **未実装** (13.4に依存)

### 要件14: CLIオプションとサーバーモード

**ユーザーストーリー:** sageを様々な環境で実行するユーザーとして、コマンドラインオプションで動作モードを切り替えたい。Local MCP（Stdio）とRemote MCP（HTTP）を柔軟に選択できるようにするため。

#### 受け入れ基準

1. `--remote`オプションが指定されたとき、システムはHTTPサーバーモードで起動すること
2. オプションなしで起動されたとき、システムはStdioトランスポート（Local MCP）モードで起動すること
3. `--config <path>`オプションが指定されたとき、システムは指定されたパスの設定ファイルを読み込むこと
4. `--port <number>`オプションが指定されたとき、システムは指定されたポートでHTTPサーバーを起動すること（デフォルト: 3000）
5. `--host <address>`オプションが指定されたとき、システムは指定されたアドレスでリッスンすること（デフォルト: 0.0.0.0）
6. 環境変数`SAGE_REMOTE_MODE=true`が設定されているとき、システムはHTTPサーバーモードで起動すること
7. 環境変数`SAGE_PORT`が設定されているとき、システムは指定されたポートを使用すること
8. 環境変数`SAGE_AUTH_SECRET`が設定されているとき、システムはJWT認証のシークレットキーとして使用すること
9. HTTPサーバーモードで起動後、システムは`/health`エンドポイントでヘルスチェックに応答すること
10. HTTPサーバーモードで起動後、システムは`/mcp`エンドポイントでMCPリクエストを受け付けること

### 要件15: Remote MCP設定ファイルと認証

**ユーザーストーリー:** Remote MCPサーバーを運用するユーザーとして、設定ファイルでサーバー設定と認証を管理したい。セキュアにAPIアクセスを制御できるようにするため。

#### 受け入れ基準

1. HTTPサーバーモードで起動時、システムは`~/.sage/remote-config.json`から設定を読み込むこと
2. `--remote-config <path>`オプションが指定されたとき、システムは指定されたパスのリモート設定ファイルを読み込むこと
3. 設定ファイルが存在しない場合、システムはデフォルト設定で起動すること
4. 設定ファイルに`auth.secret`が設定されているとき、システムはそれをJWT署名に使用すること
5. `/auth/token`エンドポイントにPOSTリクエストで`{"secret": "<設定されたsecret>"}`が送信されたとき、システムはJWTトークンを返すこと
6. 不正なsecretが送信されたとき、システムは401エラーを返すこと
7. 有効なJWTトークンが`Authorization: Bearer <token>`ヘッダーで送信されたとき、システムは`/mcp`エンドポイントへのアクセスを許可すること
8. 認証が有効で、トークンなしで`/mcp`にアクセスしたとき、システムは401エラーを返すこと
9. 設定ファイルの`cors.allowedOrigins`に基づいて、システムはCORSヘッダーを設定すること
10. 設定ファイルの検証に失敗したとき、システムは起動時にエラーメッセージを表示して終了すること

> **設定ファイル例** (`~/.sage/remote-config.json`):
> ```json
> {
>   "remote": {
>     "enabled": true,
>     "port": 3000,
>     "host": "0.0.0.0",
>     "auth": {
>       "type": "jwt",
>       "secret": "your-secure-secret-key-at-least-32-chars",
>       "expiresIn": "24h"
>     },
>     "cors": {
>       "allowedOrigins": ["*"]
>     }
>   }
> }
> ```

### 要件16: カレンダーイベント一覧取得

**ユーザーストーリー:** ワークフロー分析を行うユーザーとして、指定した期間のカレンダーイベントを一覧取得したい。作業リズムの把握やスケジュール確認ができるようにするため。

#### 受け入れ基準

1. `list_calendar_events`ツールが呼び出されたとき、システムは指定された期間のイベントを返すこと
2. 入力パラメータとして`startDate`（必須）、`endDate`（必須）、`calendarName`（オプション）を受け付けること
3. 日付形式はISO 8601形式（例: `2025-01-15`）を使用すること
4. `calendarName`が指定されたとき、システムは該当カレンダーのイベントのみを返すこと
5. `calendarName`が省略されたとき、システムはすべてのカレンダーのイベントを返すこと
6. 繰り返しイベントの場合、システムは指定期間内の各発生（occurrence）を個別のイベントとして返すこと
7. 終日イベントの場合、システムは`isAllDay: true`を含むイベントを返すこと
8. 複数日にまたがるイベントの場合、システムは正確な開始・終了日時を返すこと
9. タイムゾーンはJST（Asia/Tokyo）をデフォルトとして使用すること
10. イベントごとに`id`、`title`、`start`、`end`、`isAllDay`、`calendar`、`location`（オプション）を含むこと
11. カレンダーアクセス権限は`find_available_slots`と同じEventKit統合を使用すること
12. カレンダーアクセスが利用できない場合、システムは適切なエラーメッセージを返すこと

> **出力例:**
> ```json
> {
>   "events": [
>     {
>       "id": "event-uuid-1",
>       "title": "チームミーティング",
>       "start": "2025-01-15T10:00:00+09:00",
>       "end": "2025-01-15T11:00:00+09:00",
>       "isAllDay": false,
>       "calendar": "Work",
>       "location": "会議室A"
>     },
>     {
>       "id": "event-uuid-2",
>       "title": "休暇",
>       "start": "2025-01-16",
>       "end": "2025-01-17",
>       "isAllDay": true,
>       "calendar": "Personal"
>     }
>   ],
>   "period": {
>     "start": "2025-01-15",
>     "end": "2025-01-20"
>   },
>   "totalEvents": 2
> }
> ```

### 要件17: カレンダーイベントへの返信

**ユーザーストーリー:** 休暇や長期不在を計画するユーザーとして、指定期間のカレンダーイベントに一括で不参加返信したい。年末年始や休暇中の予定を効率的に辞退できるようにするため。

#### 受け入れ基準

1. `respond_to_calendar_event`ツールが呼び出されたとき、システムは指定されたイベントに返信を送ること
2. 入力パラメータとして`eventId`（必須）、`response`（必須: "accept"/"decline"/"tentative"）、`comment`（オプション）を受け付けること
3. `respond_to_calendar_events_batch`ツールが呼び出されたとき、システムは複数のイベントに一括で返信を送ること
4. バッチツールは`eventIds`（必須: 配列）、`response`（必須）、`comment`（オプション）を受け付けること
5. Google Calendarイベント（`@google.com`を含むID）の場合、システムはGoogle Calendar APIまたはCalendar.appを経由して返信すること
6. iCloud/ローカルイベントの場合、システムはEventKitを使用して返信を試みること
7. ユーザーが主催者であるイベントの場合、システムは警告を返して処理をスキップすること
8. 繰り返しイベントの場合、システムは指定されたインスタンスのみに返信し、シリーズ全体には影響しないこと
9. 出席者情報のないイベント（個人の予定）の場合、システムは「辞退不可」として処理をスキップすること
10. 読み取り専用カレンダーの場合、システムは適切なエラーメッセージを返すこと
11. 返信が成功したとき、システムは処理結果のサマリーを返すこと
12. バッチ処理の場合、システムは成功・失敗・スキップの件数を含むサマリーを返すこと

#### 技術的制約

- **EventKit制約**: `EKParticipant`は読み取り専用であり、直接ステータス変更ができない場合がある
- **Google Calendar**: OAuth2認証が必要（スコープ: `https://www.googleapis.com/auth/calendar.events`）
- **代替手段**: Calendar.appを経由したUI操作、またはcalendar://スキーム

#### エッジケース

| ケース | 動作 |
|--------|------|
| 自分が主催者 | スキップ（警告） |
| 終日イベント | 通常どおり処理 |
| 繰り返しイベント | 単一インスタンスのみ変更 |
| 出席者なし（個人の予定） | スキップ（辞退不可） |
| 読み取り専用カレンダー | エラー |

> **使用例:**
> ```
> ユーザー: "12/30〜1/2までのすべての予定に不参加で返事して"
>
> Sage:
> 1. list_calendar_events(startDate: "2025-12-30", endDate: "2026-01-02")
> 2. 個人の予定（👪、🏠など）をフィルタリング
> 3. respond_to_calendar_events_batch(
>      eventIds: [...フィルタされたビジネスミーティングID...],
>      response: "decline",
>      comment: "年末年始休暇のため"
>    )
> 4. 辞退したイベントのサマリーを返す
> ```

> **出力例（バッチ）:**
> ```json
> {
>   "success": true,
>   "summary": {
>     "total": 15,
>     "declined": 12,
>     "skipped": 3,
>     "failed": 0
>   },
>   "details": {
>     "declined": [
>       {"id": "event-1", "title": "Weekly Standup", "reason": "辞退しました"},
>       {"id": "event-2", "title": "1on1 with Manager", "reason": "辞退しました"}
>     ],
>     "skipped": [
>       {"id": "event-3", "title": "Team Outing", "reason": "主催者のためスキップ"},
>       {"id": "event-4", "title": "個人の予定", "reason": "出席者なしのためスキップ"}
>     ]
>   },
>   "message": "15件中12件のイベントを辞退しました。3件はスキップされました。"
> }
> ```

### 要件18: カレンダーイベントの作成

**ユーザーストーリー:** 効率的に仕事を進めたいユーザーとして、会話の中でカレンダーにイベントを直接作成したい。別のアプリを開かずにスケジュールを管理できるようにするため。

#### 受け入れ基準

1. `create_calendar_event`ツールが呼び出されたとき、システムはカレンダーに新しいイベントを作成すること
2. 入力パラメータとして`title`（必須）、`startDate`（必須: ISO 8601形式）、`endDate`（必須: ISO 8601形式）を受け付けること
3. オプションパラメータとして`location`、`notes`、`calendarName`、`alarms`を受け付けること
4. `alarms`は相対時間文字列の配列（例: `["-15m", "-1h", "-1d"]`）で指定すること
5. `calendarName`が指定されていない場合、システムはデフォルトカレンダーを使用すること
6. イベント作成時、システムはEventKit経由でカレンダーに書き込むこと
7. 終日イベントの場合（開始・終了時刻が00:00:00）、システムは`isAllDay: true`として作成すること
8. 指定されたカレンダーが存在しない場合、システムは適切なエラーメッセージを返すこと
9. 読み取り専用カレンダーの場合、システムは適切なエラーメッセージを返すこと
10. イベント作成が成功したとき、システムは作成されたイベントのID、タイトル、日時を返すこと
11. カレンダーアクセス権限がない場合、システムは適切なエラーメッセージを返すこと

#### 技術的詳細

- **EventKit使用**: AppleScriptObjC経由でEventKitフレームワークを使用
- **日付フォーマット**: ISO 8601形式（例: `2025-01-15T10:00:00+09:00`）
- **アラーム相対時間**: マイナス符号で開始前を表す（`-15m`=15分前、`-1h`=1時間前、`-1d`=1日前）

#### 入力スキーマ

```typescript
interface CreateCalendarEventRequest {
  title: string;                    // 必須: イベントタイトル
  startDate: string;                // 必須: ISO 8601形式の開始日時
  endDate: string;                  // 必須: ISO 8601形式の終了日時
  location?: string;                // オプション: 場所
  notes?: string;                   // オプション: メモ
  calendarName?: string;            // オプション: カレンダー名（未指定時はデフォルト）
  alarms?: string[];                // オプション: アラーム設定（例: ["-15m", "-1h"]）
}
```

#### 出力スキーマ

```typescript
interface CreateCalendarEventResult {
  success: boolean;
  eventId?: string;                 // 作成されたイベントID
  title?: string;                   // イベントタイトル
  startDate?: string;               // 開始日時
  endDate?: string;                 // 終了日時
  calendarName?: string;            // 作成先カレンダー名
  isAllDay?: boolean;               // 終日イベントかどうか
  error?: string;                   // エラーメッセージ
  message: string;                  // 結果メッセージ
}
```

> **使用例:**
> ```
> ユーザー: "来週の火曜日14時から15時まで、田中さんとの1on1をカレンダーに入れて"
>
> Sage:
> create_calendar_event(
>   title: "田中さんとの1on1",
>   startDate: "2025-01-14T14:00:00+09:00",
>   endDate: "2025-01-14T15:00:00+09:00",
>   alarms: ["-15m"]
> )
> ```

> **出力例:**
> ```json
> {
>   "success": true,
>   "eventId": "E1234-5678-ABCD",
>   "title": "田中さんとの1on1",
>   "startDate": "2025-01-14T14:00:00+09:00",
>   "endDate": "2025-01-14T15:00:00+09:00",
>   "calendarName": "Work",
>   "isAllDay": false,
>   "message": "カレンダーに「田中さんとの1on1」を作成しました（2025-01-14 14:00-15:00）"
> }
> ```

#### 将来の拡張（現時点ではスコープ外）

- `update_calendar_event` - 既存イベントの更新
- `delete_calendar_event` - イベントの削除
- `create_recurring_event` - 繰り返しルール付きイベント
- 参加者管理（招待状の送信）
